(window.webpackJsonp=window.webpackJsonp||[]).push([[114],{490:function(r,t,p){"use strict";p.r(t);var e=p(44),o=Object(e.a)({},(function(){var r=this,t=r.$createElement,p=r._self._c||t;return p("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[p("h1",{attrs:{id:"vue单向数据流的理解"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#vue单向数据流的理解"}},[r._v("#")]),r._v(" Vue单向数据流的理解")]),r._v(" "),p("ul",[p("li",[r._v("所有的prop都使得父子prop之间形成一个单向下行绑定，父级prop的更新会向下流动到子组件中，"),p("br"),r._v("\n反之则不行。这样可以阻止子组件改变父组件的状态，从而导致应用数据流难以理解。每次父组件"),p("br"),r._v("\nprop值更新时，子组件所有的prop都将刷新为最新的值。子组件想要修改父组件的prop，只能通过"),p("br"),r._v("\n$emit派发一个自定义事件，父组件可在该事件中触发prop更新。")])]),r._v(" "),p("blockquote",[p("p",[r._v("提示"),p("br"),r._v("\n注意在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，"),p("br"),r._v("\n在子组件中改变变更这个对象或数组本身将会影响到父组件的状态。")])])])}),[],!1,null,null,null);t.default=o.exports}}]);