(window.webpackJsonp=window.webpackJsonp||[]).push([[120],{500:function(t,e,r){"use strict";r.r(e);var n=r(44),a=Object(n.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"runtime-manifest"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#runtime-manifest"}},[t._v("#")]),t._v(" runtime && manifest")]),t._v(" "),r("h2",{attrs:{id:"runtime"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#runtime"}},[t._v("#")]),t._v(" runtime")]),t._v(" "),r("ul",[r("li",[t._v("runtime 以及伴随的 manifest 数据，是指在浏览器运行过程中，webpack 用来连接模块化应用程序所需的所有代码。"),r("br"),t._v("\n它包含：在模块交互时，连接模块所需的加载和解析逻辑，以及，已经加载到浏览器中的连接模块逻辑，和尚未加载模块的延迟加载逻辑。")])]),t._v(" "),r("h2",{attrs:{id:"manifest"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#manifest"}},[t._v("#")]),t._v(" manifest")]),t._v(" "),r("ul",[r("li",[t._v("当 compiler 开始执行，解析和映射应用程序时，它会保留所有模块的详细要点。这个数据集合被称为‘manifest’，当完成打包并发送到浏览器时，"),r("br"),t._v("\nruntime 会通过 manifest 来解析和加载模块。import 和 require 语句被转换为 "),r("strong",[t._v("webpack_require")]),t._v(" 方法，此方法指向模块标识符(module identifier)，"),r("br"),t._v("\n通过使用 manifest 中的数据， runtime 能够解锁这些标识符，找出每个标识符对应的模块。")])])])}),[],!1,null,null,null);e.default=a.exports}}]);