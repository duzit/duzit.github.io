(window.webpackJsonp=window.webpackJsonp||[]).push([[113],{488:function(t,e,a){"use strict";a.r(e);var r=a(44),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"vuex"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vuex"}},[t._v("#")]),t._v(" Vuex")]),t._v(" "),a("h3",{attrs:{id:"vuex-和单纯的全局对象有以下两点不同"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vuex-和单纯的全局对象有以下两点不同"}},[t._v("#")]),t._v(" Vuex 和单纯的全局对象有以下两点不同")]),t._v(" "),a("ul",[a("li",[t._v("Vuex 的状态储存是响应式的。若store中的状态发生改变，那么相应的组件也会得到高效更新。")]),t._v(" "),a("li",[t._v("不能直接改变store的状态。改变store中的状态唯一途径是显示的提交（commit）mutation。"),a("br"),t._v("\n因为想要更明确地追踪状态的变化")])]),t._v(" "),a("h3",{attrs:{id:"在-vue-组件中获得-vuex-状态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#在-vue-组件中获得-vuex-状态"}},[t._v("#")]),t._v(" 在 Vue 组件中获得 Vuex 状态")]),t._v(" "),a("ul",[a("li",[t._v("Vuex 通过在根实例中注册 store 选项，提供一种机制将状态从根组件注入到每一个子组件中"),a("br"),t._v("\n（需调用Vue.use(Vuex) ）。 子组件能通过 this.$store 访问到。")])]),t._v(" "),a("h3",{attrs:{id:"mutation-必须是同步函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mutation-必须是同步函数"}},[t._v("#")]),t._v(" Mutation 必须是同步函数")]),t._v(" "),a("ul",[a("li",[t._v("任何在回调函数中进行的状态的改变都是不可追踪的")])]),t._v(" "),a("h3",{attrs:{id:"action"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#action"}},[t._v("#")]),t._v(" Action")]),t._v(" "),a("ul",[a("li",[t._v("Action 提交的是 mutation ，而不是直接改变状态。")]),t._v(" "),a("li",[t._v("Action 可以包含任意异步操作")])]),t._v(" "),a("h3",{attrs:{id:"module"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#module"}},[t._v("#")]),t._v(" Module")]),t._v(" "),a("ul",[a("li",[t._v("由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，"),a("br"),t._v("\n就有可能变得相当臃肿。 为解决以上问题，Vuex允许将store分割成模块（Module）。")])])])}),[],!1,null,null,null);e.default=s.exports}}]);