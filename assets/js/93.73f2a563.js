(window.webpackJsonp=window.webpackJsonp||[]).push([[93],{467:function(t,e,v){"use strict";v.r(e);var _=v(44),l=Object(_.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"闭包的理解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#闭包的理解"}},[t._v("#")]),t._v(" 闭包的理解")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("链式作用域结构，子对象会一级一级地向上寻找所有父对象的变量。\n所以，父对象的所有变量，对子对象都是可见的，反之则不成立。")])]),t._v(" "),v("li",[v("p",[t._v("优缺点")])])]),t._v(" "),v("blockquote",[v("p",[t._v("优点：可以避免全局变量的污染"),v("br"),t._v("\n缺点：常驻内存，增加内存使用量，使用不当容易造成内存泄露。")])]),t._v(" "),v("ul",[v("li",[t._v("特性")])]),t._v(" "),v("blockquote",[v("p",[t._v("函数嵌套函数"),v("br"),t._v("\n在函数内部可以引用外部的参数和变量"),v("br"),t._v("\n参数和变量不会以垃圾回收机制回收")])]),t._v(" "),v("ul",[v("li",[t._v("作用")])]),t._v(" "),v("blockquote",[v("p",[t._v("可以读取函数内部的变量"),v("br"),t._v("\n让这些变量的值始终保持在内存中，不会在调用后被自动清除")])]),t._v(" "),v("ul",[v("li",[t._v("用途")])]),t._v(" "),v("blockquote",[v("p",[t._v("采用函数引用方式的setTimeout调用，原生的setTimeout有一个缺陷，你传递的第一个函数不能带参数"),v("br"),t._v("\n封装相关的功能集")])])])}),[],!1,null,null,null);e.default=l.exports}}]);